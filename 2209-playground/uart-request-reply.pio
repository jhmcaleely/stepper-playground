; A PIO program that performs a request-reply transaction on a bidirectional UART.

.pio_version 0

.program uart_request_reply
.side_set 1 opt

; An 8n1 UART write then read transaction on one pin.
; OUT pin 0 and side-set pin 0 are both mapped to UART pin.
; IN pin 0 is the same pin.
; Uses 8 state machine cycles as period for the signal

    set y, 3
writeloop:
    pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state
    set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks
bitloopw:                  ; This loop will run 8 times (8n1 UART)
    out pins, 1            ; Shift 1 bit from OSR to the first OUT pin
    jmp x-- bitloopw  [6]  ; Each loop iteration is 8 cycles.
    jmp y-- writeloop

    set y, 7             ; response will be 8 bytes long.
readloop:
    wait 0 pin 0         ; Wait for start bit
    set x, 7 [7]         ; Preload bit counter (for 8 loops)
    nop      [3]         ; delay until we sample at middle of bit cycle
bitloopr:
    in pins, 1           ; Sample data
    jmp x-- bitloopr [6] ; Each iteration is 8 cycles
    jmp y-- readloop


.program uart_request_reply_strict
.side_set 1 opt

; An 8n1 UART write then read transaction on one pin.
; OUT pin 0 and side-set pin 0 are both mapped to UART pin.
; IN pin 0 is the same pin.

    set y, 3
writeloop:
    pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state
    set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks
bitloopw:                   ; This loop will run 8 times (8n1 UART)
    out pins, 1            ; Shift 1 bit from OSR to the first OUT pin
    jmp x-- bitloopw   [6]  ; Each loop iteration is 8 cycles.
    jmp y-- writeloop

    set y, 7
readloop:
start:
    wait 0 pin 0        ; Stall until start bit is asserted
    set x, 7    [7]    ; Preload bit counter...
    nop [1]             ; ... then delay until halfway through
bitloopr:                ; the first data bit (12 cycles incl wait, set).
    in pins, 1          ; Shift data bit into ISR
    jmp x-- bitloopr [6] ; Loop 8 times, each loop iteration is 8 cycles
    jmp pin good_stop   ; Check stop bit (should be high)

    irq 4 rel           ; Either a framing error or a break. Set a sticky flag,
    wait 1 pin 0        ; and wait for line to return to idle state.
    jmp start           ; Don't push data if we didn't see good framing.

good_stop:              ; No delay before returning to start; a little slack is
    push                ; important in case the TX clock is slightly too fast.
    jmp y-- readloop
